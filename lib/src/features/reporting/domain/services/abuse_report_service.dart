import 'dart:convert';
import 'dart:typed_data';

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:share_plus/share_plus.dart';
import 'package:url_launcher/url_launcher.dart';

import 'package:six7_chat/src/features/messaging/domain/models/chat_message.dart';
import 'package:six7_chat/src/features/reporting/domain/models/abuse_report.dart';

/// Default abuse reporting email.
const String defaultAbuseEmail = 'abuse@six7.chat';

/// Provider for the abuse report service.
final abuseReportServiceProvider = Provider<AbuseReportService>((ref) {
  return AbuseReportService();
});

/// Service for generating and sharing abuse reports.
/// 
/// Abuse reports contain cryptographic proof (message franking) that
/// the reported content was authentically sent by the identified sender.
/// The proof is self-contained and can be verified offline by anyone.
class AbuseReportService {
  /// Generates a verifiable abuse report for a message.
  /// 
  /// Throws [ReportException] if the message lacks franking data.
  AbuseReport generateReport({
    required ChatMessage message,
    required String senderDisplayName,
    required String reporterIdentity,
    String? groupId,
    String? groupName,
    String? statement,
    List<String>? contextMessageIds,
  }) {
    // Validate franking data exists
    if (message.frankingTag == null || message.frankingKey == null) {
      throw ReportException(
        'Message lacks franking data. '
        'This may be a legacy message sent before franking was enabled.',
      );
    }

    return AbuseReport(
      version: '1',
      generatedAt: DateTime.now(),
      senderIdentity: message.senderId,
      senderDisplayName: senderDisplayName,
      messageId: message.id,
      timestampMs: message.timestamp.millisecondsSinceEpoch,
      reportedContent: message.text,
      frankingTag: message.frankingTag!,
      frankingKey: message.frankingKey!,
      keyCommitment: message.frankingKeyCommitment ?? Uint8List(0),
      reporterIdentity: reporterIdentity,
      groupId: groupId,
      groupName: groupName,
      contextMessageIds: contextMessageIds,
      statement: statement,
    );
  }

  /// Opens email composer with report attached.
  /// 
  /// Returns true if email was launched successfully.
  Future<bool> sendViaEmail(
    AbuseReport report, {
    String email = defaultAbuseEmail,
  }) async {
    final json = report.toJsonString();
    final truncatedSender = _truncateId(report.senderIdentity);
    final date = report.generatedAt.toIso8601String().split('T')[0];

    final subject = Uri.encodeComponent(
      'Six7 Abuse Report - Sender $truncatedSender',
    );
    
    final isGroup = report.groupId != null;
    final body = Uri.encodeComponent('''
I am reporting abusive content from a Six7 user.

Sender ID: ${report.senderIdentity}
Sender Name: ${report.senderDisplayName}
Message Time: ${DateTime.fromMillisecondsSinceEpoch(report.timestampMs)}
${isGroup ? 'Group: ${report.groupName ?? report.groupId}' : 'Chat Type: Direct Message'}
${report.statement != null ? '\nContext: ${report.statement}' : ''}

The attached JSON file contains cryptographic proof that this message 
was authentically sent by the reported user. You can verify it using 
the six7-verify tool or any HMAC-SHA256 implementation.

---
This report was generated by Six7.
''');

    // Try to open email client
    final mailtoUri = Uri.parse('mailto:$email?subject=$subject&body=$body');

    try {
      if (await canLaunchUrl(mailtoUri)) {
        await launchUrl(mailtoUri);

        // Share the JSON file separately (mailto doesn't support attachments well)
        await _shareJsonFile(
          json,
          'six7_report_${date}_${report.messageId.substring(0, 8)}.json',
        );
        return true;
      } else {
        // Fallback: share everything via system share sheet
        await shareReport(report);
        return true;
      }
    } catch (e) {
      debugPrint('[AbuseReport] Email failed: $e');
      // Fallback to generic share
      await shareReport(report);
      return true;
    }
  }

  /// Shares report via system share sheet (for any destination).
  Future<void> shareReport(AbuseReport report) async {
    final json = report.toJsonString();
    final date = report.generatedAt.toIso8601String().split('T')[0];
    final truncatedSender = _truncateId(report.senderIdentity);

    await _shareJsonFile(
      json,
      'six7_report_${date}_${truncatedSender}.json',
      text: 'Six7 Abuse Report - Cryptographically verified\n\n'
          '${report.verificationSummary}',
    );
  }

  /// Shares the report as a JSON file.
  Future<void> _shareJsonFile(
    String json,
    String filename, {
    String? text,
  }) async {
    try {
      await Share.shareXFiles(
        [
          XFile.fromData(
            utf8.encode(json),
            name: filename,
            mimeType: 'application/json',
          ),
        ],
        subject: 'Six7 Abuse Report',
        text: text,
      );
    } catch (e) {
      // Fallback: share as plain text
      debugPrint('[AbuseReport] XFile share failed: $e, falling back to text');
      await Share.share(
        '${text ?? ''}\n\n$json',
        subject: 'Six7 Abuse Report',
      );
    }
  }

  /// Saves report to a string (for copying).
  String exportToString(AbuseReport report) {
    return report.toJsonString();
  }

  /// Verifies a report from JSON string.
  /// Returns the report if valid, throws if invalid.
  AbuseReport verifyFromJson(String jsonString) {
    final json = jsonDecode(jsonString) as Map<String, dynamic>;

    // Extract fields
    final sender = json['sender'] as Map<String, dynamic>;
    final message = json['message'] as Map<String, dynamic>;
    final proof = json['franking_proof'] as Map<String, dynamic>;
    final context = json['context'] as Map<String, dynamic>;

    final report = AbuseReport(
      version: json['version'] as String,
      generatedAt: DateTime.parse(json['generated_at'] as String),
      senderIdentity: sender['identity'] as String,
      senderDisplayName: sender['display_name'] as String,
      messageId: message['id'] as String,
      timestampMs: message['timestamp_ms'] as int,
      reportedContent: message['reported_content'] as String,
      frankingTag: base64Decode(proof['tag'] as String),
      frankingKey: base64Decode(proof['key'] as String),
      keyCommitment: base64Decode(proof['key_commitment'] as String),
      reporterIdentity: context['reporter_identity'] as String,
      groupId: context['group_id'] as String?,
      groupName: context['group_name'] as String?,
      contextMessageIds: (context['surrounding_message_ids'] as List<dynamic>?)
          ?.cast<String>(),
      statement: json['reporter_statement'] as String?,
    );

    // Verify the proof
    final error = report.verify();
    if (error != null) {
      throw ReportVerificationException(error);
    }

    return report;
  }

  String _truncateId(String id) {
    if (id.length <= 12) return id;
    return '${id.substring(0, 6)}...${id.substring(id.length - 4)}';
  }
}

/// Exception thrown when report generation fails.
class ReportException implements Exception {
  const ReportException(this.message);
  final String message;

  @override
  String toString() => 'ReportException: $message';
}

/// Exception thrown when report verification fails.
class ReportVerificationException implements Exception {
  const ReportVerificationException(this.message);
  final String message;

  @override
  String toString() => 'ReportVerificationException: $message';
}
